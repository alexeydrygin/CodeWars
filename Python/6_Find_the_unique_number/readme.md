## Find the unique number

There is an array with some numbers. All numbers are equal except for one. Try to find it!

```
find_uniq([ 1, 1, 1, 2, 1, 1 ]) == 2
find_uniq([ 0, 0, 0.55, 0, 0 ]) == 0.55
```

It’s guaranteed that array contains at least 3 numbers.

The tests contain some very huge arrays, so think about performance.

---

## У вас есть массив с некоторыми числами. Все числа равны, за исключением одного. Попробуйте найти его!

```
find_uniq([ 1, 1, 1, 2, 1, 1 ]) == 2
find_uniq([ 0, 0, 0.55, 0, 0 ]) == 0.55
```

Гарантируется, что в массиве есть как минимум 3 числа. Тесты содержат очень большие массивы, поэтому нужно думать о производительности.

Для решения этой задачи можно воспользоваться тем фактом, что массив содержит как минимум три числа, и все числа равны, за исключением одного. Это означает, что мы можем просто сравнить первые три числа массива и найти то, которое отличается от других. Как только мы найдем его, мы можем вернуть его.

Это решение имеет сложность O(1) в лучшем случае (когда уникальное число находится среди первых двух чисел) и O(n) в худшем случае (когда уникальное число является последним числом в массиве). Однако, поскольку мы сравниваем только три числа в массиве, то худший случай маловероятен для больших массивов. Поэтому это решение должно быть достаточно эффективным для данной задачи.

## Другие решения:

```python
# Данный код реализует функцию find_uniq, которая принимает в качестве аргумента список arr, состоящий из чисел или других хэшируемых объектов, в котором все элементы повторяются, за исключением одного.

#Код начинается с распаковки множества, полученного из списка arr, в две переменные a и b. Так как список arr содержит только один уникальный элемент, то множество будет состоять из двух элементов.

#Далее происходит проверка количества вхождений элемента a в список arr с помощью метода count(). Если a встречается в списке только один раз, то функция возвращает a, иначе она возвращает b. Таким образом, функция возвращает уникальный элемент списка.

#Получается, что этот код эффективно решает поставленную задачу и выполняет все необходимые проверки. Он короткий и простой в понимании, что делает его хорошим выбором для быстрого и надежного решения этой задачи. Однако, если список arr будет содержать большое количество элементов, то данный код может иметь проблемы с производительностью из-за использования метода count(), который выполняет линейный поиск в списке. В таком случае более оптимальным решением будет использование словаря, чтобы подсчитать количество вхождений каждого элемента в список.

def find_uniq(arr):
    a, b = set(arr)
    return a if arr.count(a) == 1 else b
```

```python
#Данный код также реализует функцию find_uniq, которая принимает в качестве аргумента список arr, состоящий из чисел или других хэшируемых объектов, в котором все элементы повторяются, за исключением одного.

#Код начинается с сортировки списка arr с помощью функции sorted(). Так как в списке arr только один элемент отличается от остальных, то этот элемент окажется либо первым в отсортированном списке, либо последним. Далее с помощью условного оператора проверяется, находится ли уникальный элемент в начале списка a. Если это так, то функция возвращает первый элемент списка a, иначе она возвращает последний элемент списка a. Таким образом, функция возвращает уникальный элемент списка.

#Этот код также эффективно решает поставленную задачу и выполняет все необходимые проверки. Однако он несколько менее читаем, чем предыдущий код, так как требует знания деталей сортировки и индексации списков. Кроме того, он также может иметь проблемы с производительностью на больших списках, так как сортировка выполняется за время O(n*log(n)), что может быть медленнее, чем подсчет количества вхождений каждого элемента в словаре.

def find_uniq(arr):
    a = sorted(arr)
    return a[0] if a[0] != a[1] else a[-1]
```

```python

#Данный код также реализует функцию find_uniq, которая принимает в качестве аргумента список arr, состоящий из чисел или других хэшируемых объектов, в котором все элементы повторяются, за исключением одного.

#Код начинается с создания множества из списка arr с помощью функции set(), которая удаляет дубликаты из списка. Далее используется генератор списка, чтобы создать новый список из элементов, которые встречаются в списке arr только один раз. Для этого проверяется количество вхождений каждого элемента в список arr с помощью метода count(). Из списка выбирается первый элемент с помощью индексации [0] и возвращается в качестве результата.

#Этот код также решает поставленную задачу, однако он менее эффективный, чем первый код, так как он использует генератор списка и метод count(), который выполняет линейный поиск в списке для каждого элемента множества. Это может привести к плохой производительности на больших списках. Кроме того, он также может иметь проблемы с памятью на больших списках, так как он создает новый список, который может занимать много памяти, если список arr очень большой.

def find_uniq(arr):
    return [x for x in set(arr) if arr.count(x) == 1][0]
```

```python

#Данный код также реализует функцию find_uniq, которая принимает в качестве аргумента список arr, состоящий из чисел или других хэшируемых объектов, в котором все элементы повторяются, за исключением одного.

#Код начинается с создания множества из списка arr с помощью функции set(), которая удаляет дубликаты из списка. Затем используется встроенная функция min(), которая принимает множество set(arr) в качестве первого аргумента и ключевую функцию key=arr.count в качестве второго аргумента. Ключевая функция arr.count возвращает количество вхождений элемента x в список arr. Функция min() использует ключевую функцию arr.count для определения минимального элемента множества set(arr), который имеет наименьшее количество вхождений в список arr.

#Этот код также решает поставленную задачу и выполняет все необходимые проверки. Он также более читаемый и лаконичный, чем предыдущие два кода. Кроме того, он является более эффективным, чем второй код, так как он использует только одно проходное сканирование списка и не создает новый список. Однако, он может быть менее эффективным, чем первый код, если множество set(arr) очень большое, так как он выполняет arr.count(x) для каждого элемента в множестве.

def find_uniq(arr):
        return min(set(arr),key=arr.count)
```
